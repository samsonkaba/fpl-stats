"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const async = require("async");
const _ = require("lodash");
const dataService = require("./data.service");
// *************
// Entry methods
// *************
/**
 * Returns entry summary / details.
 * @param entryId The id of entry
 */
function findEntry(entryId) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findEntryRoot(entryId);
        return data.entry;
    });
}
exports.findEntry = findEntry;
/**
 * Returns a collection of completed or ongoing events
 * @param entryId The id of entry
 */
function findEntryEvents(entryId) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findEntryRoot(entryId);
        return data.history;
    });
}
exports.findEntryEvents = findEntryEvents;
/**
 * Returns chip details of a specified entry
 * @param entryId The id of entry
 * @param eventNumber The event number
 */
function findEntryChips(entryId) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findEntryRoot(entryId);
        return data.chips;
    });
}
exports.findEntryChips = findEntryChips;
/**
 * Returns a details of a specified event
 * @param entryId The id of entry
 * @param eventNumber The event number
 */
function findEntryEvent(entryId, eventNumber) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findEntryEventPicksRoot(entryId, eventNumber);
        return data.entry_history;
    });
}
exports.findEntryEvent = findEntryEvent;
/**
 * Returns a collection of picks for a specified event
 * @param entryId The id of entry
 * @param event The event number
 */
function findEntryPicks(entryId) {
    return new Promise((resolve, reject) => {
        Promise.all([getElements(), findEntryEvents(entryId)]).then((result) => {
            const elements = result[0];
            const gameweeks = result[1];
            const picks = [];
            async.each(gameweeks, (gameweek, nextGameweek) => {
                const event = gameweek.event;
                Promise.all([findElementsByEvent(event), findEntryPicksByEvent(entryId, event)]).then((result1) => {
                    const eventElements = result1[0];
                    const entryPicks = result1[1].map((entryPick, i) => {
                        const isSub = i > 10;
                        return Object.assign({}, entryPick, { is_sub: isSub });
                    });
                    const pickDataArray = [];
                    async.each(entryPicks, (pick, nextPicks) => {
                        const picksData = eventElements[pick.element].stats;
                        pickDataArray.push(Object.assign({}, picksData, { element: pick.element, is_captain: pick.is_captain, is_sub: pick.is_sub }));
                        nextPicks();
                    }, (err) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            picks.push(pickDataArray);
                            nextGameweek();
                        }
                    });
                });
            }, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    const groupedPlayers = _.groupBy(_.flatten(picks), 'element');
                    const players = _.toArray(_.mapValues(groupedPlayers, (value, playerKey) => {
                        const player = _.reduce(value, (playerResult, pick) => {
                            function setProp(prop, increment = false, propOveride) {
                                playerResult[prop] =
                                    increment ? playerResult[prop] + 1 :
                                        playerResult[prop] + pick[propOveride ? propOveride : prop];
                            }
                            if (pick.is_captain) {
                                setProp('times_captained', true);
                                setProp('total_captain_points', false, 'total_points');
                            }
                            if (!pick.is_sub && pick.minutes > 0) {
                                setProp('times_played', true);
                                Object.keys(pick)
                                    .filter((key) => {
                                    return key !== 'is_sub'
                                        && key !== 'is_captain'
                                        && key !== 'element'
                                        && key !== 'creativity'
                                        && key !== 'ict_index'
                                        && key !== 'in_dreamteam'
                                        && key !== 'threat';
                                })
                                    .forEach((key) => {
                                    setProp(key);
                                });
                            }
                            else if (pick.minutes > 0) {
                                setProp('times_benched', true);
                                setProp('total_bench_points', false, 'total_points');
                            }
                            else {
                                setProp('times_absent', true);
                            }
                            return playerResult;
                        }, {
                            yellow_cards: 0,
                            own_goals: 0,
                            goals_conceded: 0,
                            bonus: 0,
                            red_cards: 0,
                            saves: 0,
                            influence: 0,
                            bps: 0,
                            clean_sheets: 0,
                            assists: 0,
                            goals_scored: 0,
                            penalties_missed: 0,
                            total_points: 0,
                            penalties_saved: 0,
                            minutes: 0,
                            times_played: 0,
                            times_benched: 0,
                            times_absent: 0,
                            times_captained: 0,
                            total_captain_points: 0,
                            total_bench_points: 0,
                        });
                        const element = _.find(elements, { id: parseInt(playerKey, 10) } || elements[0]);
                        if (element) {
                            const elementDetails = {
                                id: element.id,
                                name: element.web_name,
                                type: element.element_type,
                            };
                            const averages = {
                                average_played: player.total_points / player.times_played || 0,
                                average_benched: player.total_bench_points / player.times_benched || 0,
                                average_captained: player.total_captain_points / player.times_captained || 0,
                            };
                            const stats = Object.assign({}, player, averages);
                            return Object.assign({}, elementDetails, { stats });
                        }
                    }));
                    resolve(players);
                }
            });
        });
    });
}
exports.findEntryPicks = findEntryPicks;
/**
 * Returns some general stats
 * @param entryId
 */
function findEntryStats(entryId) {
    return new Promise((resolve, reject) => {
        Promise.all([
            findEntry(entryId),
            findEntryEvents(entryId)
        ]).then((result) => {
            const entryData = result[0];
            const gameweeksData = result[1];
            const gameweeks = _.remove(gameweeksData, (gameweek) => {
                return gameweek;
            });
            const moneyInBank = entryData.bank / 10;
            const totalValue = (entryData.value + entryData.bank) / 10;
            // ranks
            const overallRank = entryData.summary_overall_rank;
            let highestGwRank = 10000000;
            let lowestRank = 0;
            // scores
            const overallPoints = entryData.summary_overall_points;
            let highestScore = 0;
            let lowestScore = 200;
            let totalTransferCost = 0;
            gameweeks.forEach((gameweek) => {
                // ranks
                const rank = gameweek.rank;
                if (rank && rank > lowestRank) {
                    lowestRank = rank;
                }
                if (rank && rank < highestGwRank) {
                    highestGwRank = rank;
                }
                // scores
                const score = gameweek.points - gameweek.event_transfers_cost;
                if (score < lowestScore) {
                    lowestScore = score;
                }
                if (score > highestScore) {
                    highestScore = score;
                }
                // transfers
                totalTransferCost = totalTransferCost + gameweek.event_transfers_cost;
            });
            const stats = {
                overall_rank: overallRank,
                highest_gameweek_rank: highestGwRank,
                lowest_gameweek_rank: lowestRank,
                overall_points: overallPoints,
                highest_score: highestScore,
                lowest_score: lowestScore,
                average_score: overallPoints / entryData.current_event,
                total_transfer_cost: totalTransferCost,
                money_in_bank: moneyInBank,
                total_value: totalValue,
            };
            resolve(stats);
        });
    });
}
exports.findEntryStats = findEntryStats;
/**
 * Returns a collection of picks for a specified event
 * @param entryId The id of entry
 * @param event The event number
 */
function findEntryPicksByEvent(entryId, event) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findEntryEventPicksRoot(entryId, event);
        return data.picks;
    });
}
exports.findEntryPicksByEvent = findEntryPicksByEvent;
/**
 * Returns transfer history of an entry
 * @param entryId The id of entry
 */
function findEntryTransferHistory(entryId) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findEntryTransfers(entryId);
        return data.history;
    });
}
exports.findEntryTransferHistory = findEntryTransferHistory;
/**
 * Returns all element data for a specified event
 * @param event The event number
 */
function findElementsByEvent(event) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findLiveEvent(event);
        return data.elements;
    });
}
exports.findElementsByEvent = findElementsByEvent;
// *************
// League methods
// *************
/**
 * Returns specified details of a classic league
 * @param leagueId The id of the league
 */
function findLeague(leagueId) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findLeagueRoot(leagueId);
        return data.league;
    });
}
exports.findLeague = findLeague;
/**
 * Returns specified standings of a classic league
 * @param leagueId The id of the league
 * @param pageNumber The page number of the standings (50 results per page)
 */
function findLeagueStandings(leagueId, pageNumber = 1) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.findLeagueRoot(leagueId, pageNumber);
        return data.standings;
    });
}
exports.findLeagueStandings = findLeagueStandings;
// *************
// Other
// *************
/**
 * Returns a collection of all elements.
 */
function getElements() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.getBootstrapData();
        return data.elements;
    });
}
exports.getElements = getElements;
/**
 * Returns a collection of all element types in the game
 */
function getElementTypes() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.getBootstrapData();
        return data.element_types;
    });
}
exports.getElementTypes = getElementTypes;
/**
 * Returns a collection of all events
 */
function getEvents() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.getBootstrapData();
        return data.events;
    });
}
exports.getEvents = getEvents;
/**
 * Returns a collection of all teams
 */
function getTeams() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.getBootstrapData();
        return data.teams;
    });
}
exports.getTeams = getTeams;
/**
 * Returns the total number of entries
 */
function getTotalNumberOfEntries() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.getBootstrapData();
        return data['total-players'];
    });
}
exports.getTotalNumberOfEntries = getTotalNumberOfEntries;
/**
 * Returns the current event number
 */
function getCurrentEventNumber() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = yield dataService.getBootstrapData();
        return data['current-event'];
    });
}
exports.getCurrentEventNumber = getCurrentEventNumber;
